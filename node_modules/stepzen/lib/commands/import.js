"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const fs = require("fs-extra");
const command_1 = require("@oclif/command");
const errors_1 = require("@oclif/errors");
const transpiler_1 = require("@stepzen/transpiler");
const core_1 = require("@oclif/core");
const generate_1 = require("../generate");
const utils_1 = require("../shared/utils");
const helpers_1 = require("../generate/helpers");
const curl2sdl_1 = require("../generate/curl2sdl");
const curl_parser_1 = require("../shared/curl-parser");
const workspace_1 = require("../shared/workspace");
const zen_command_1 = require("../shared/zen-command");
const init_1 = require("./init");
const constants_1 = require("../shared/constants");
const path_params_parser_1 = require("../shared/path-params-parser");
class Import extends zen_command_1.default {
    async run() {
        const { args, argv, flags } = this.parse(Import);
        // Get a list of schemas you're asking for
        const schemas = helpers_1.getSchemaList(args.schemas);
        if (schemas.length > 1 && flags.name) {
            this.log('When importing several schemas the --name flag is ignored. ' +
                'In order to use the --name flag please import each schema separately.');
        }
        // Get the working directory and workspace
        let workspace;
        const directory = utils_1.getDirectory(flags.dir);
        const maybeWorkspace = workspace_1.getWorkspace(directory);
        if (maybeWorkspace) {
            workspace = maybeWorkspace;
        }
        else {
            try {
                workspace = await init_1.default.run([directory]);
            }
            catch (error) {
                throw new errors_1.CLIError(`Could not create a StepZen workspace in the ${flags.dir ? directory : 'current'} directory.\n` + error.message);
            }
        }
        // Select an import execution flow:
        //  - v1 with `stepzen/engines` and cloud function
        //  - v2 with the graphqlize service
        let result;
        if (schemas.includes('curl')) {
            // LATER: offload the check to the graphqlize service or fetch
            // the list of supported data sources and compare agains it.
            if (schemas.length > 1) {
                throw new errors_1.CLIError('Please run cURL import separately from importing other schemas');
            }
            this.log(chalk.yellow(`NOTE: ${chalk.bold('stepzen import curl')} is a ${chalk.bold('new')} feature.`));
            this.log(chalk.yellow('If you have any issues, please check if they have been addressed ' +
                'in the latest version, or reach out to StepZen on Discord: ' +
                constants_1.STEPZEN_DISCORD_URL));
            let curl2sdlOptions;
            const fixedOptions = {
                name: flags.name,
                source: workspace.schema,
            };
            const editableOptions = {
                queryName: flags['query-name'],
                rootType: flags['query-type'],
                typePrefix: flags.prefix,
                pathParams: flags['path-params'],
            };
            if (argv.length === 1) {
                // no parameters given: start an interactive prompt
                console.log();
                console.log('This command introspects the response of a REST endpoint and generates' +
                    ' a GraphQL schema allowing you to access this endpoint through your ' +
                    'StepZen API. curl syntax is supported so that you copy and paste a ' +
                    'curl command instead of the URL.');
                console.log();
                curl2sdlOptions = Object.assign(Object.assign({}, fixedOptions), (await curl2sdl_1.askCurlQuestions(editableOptions)));
            }
            else {
                // run non-interative
                const argsOrError = curl_parser_1.parseCurlArgv(argv);
                if ('error' in argsOrError) {
                    throw new errors_1.CLIError(argsOrError.error);
                }
                const parsedPathParamsOrError = path_params_parser_1.parsePathParamsPattern(argsOrError.url, flags['path-params']);
                if ('error' in parsedPathParamsOrError) {
                    throw new errors_1.CLIError(parsedPathParamsOrError.error);
                }
                curl2sdlOptions = Object.assign(Object.assign(Object.assign({}, fixedOptions), editableOptions), { pathParams: parsedPathParamsOrError, curlArgs: argsOrError });
            }
            core_1.CliUx.ux.action.start('Starting');
            const resultOrError = await curl2sdl_1.curl2sdl(curl2sdlOptions);
            core_1.CliUx.ux.action.stop();
            if ('error' in resultOrError) {
                this.log('A problem occured while processing your import. ' +
                    'Please check that the given cURL command is valid.');
                this.log(resultOrError.error);
                this.exit();
            }
            result = resultOrError.outPath;
        }
        else {
            ;
            ['prefix', 'query-type', 'query-name', 'path-params'].forEach(flag => {
                if (flag in flags) {
                    this.log(chalk.gray(`The ${chalk.bold(`--${flag}`)} flag only applies when importing ${chalk.bold('curl')}. It will be ignored now.`));
                }
            });
            // Let's go!
            result = await generate_1.default(schemas, flags.name, workspace.schema);
            // Validate
            await transpiler_1.validate(result, {
                extensions: await utils_1.getStepZenExtensions(),
            });
        }
        // Housekeeping
        fs.copySync(result, workspace.schema);
        fs.removeSync(result);
        // Nice message
        this;
        this.log(chalk.green(`Successfully imported ${schemas.length} schemas from StepZen`));
    }
}
exports.default = Import;
Import.description = 'Import a schema for an external data source or a API endpoint to your GraphQL API.';
Import.flags = Object.assign(Object.assign({}, zen_command_1.default.flags), { dir: command_1.flags.string({ description: 'working directory' }), help: command_1.flags.help({ char: 'h' }), silent: command_1.flags.boolean({ hidden: true }), name: command_1.flags.string({
        description: 'subfolder inside the workspace folder to save the imported' +
            ' schema files, defaults to the imported schema name',
    }), prefix: command_1.flags.string({
        description: '[curl] prefix to add every type in the generated schema.',
    }), 'query-name': command_1.flags.string({
        description: '[curl] property name to add to the Query type as a way to' +
            ' access the imported cURL endpoint.',
    }), 'query-type': command_1.flags.string({
        description: '[curl] name for the type returned by the cURL endpoint in the ' +
            `generated schema. The name specified by ${chalk.bold('--query-type')} is not prefixed by ${chalk.bold('--prefix')} if both flags are present.`,
    }), 'path-params': command_1.flags.string({
        description: `[curl] specifies path parameters in the URL path.` +
            ` Can be formed by taking the original path and replacing the` +
            ` variable segments with ${chalk.bold('$paramName')} placeholders.` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/users/jane/posts/12` +
            ` --path-params` +
            ` '/users/${chalk.bold('$userId')}/posts/${chalk.bold('$postId')}'`,
    }) });
Import.args = [
    {
        name: 'schemas',
        required: true,
    },
];
// allow any number of arguments to support `import curl [url] [curl flags and options]`
Import.strict = false;
