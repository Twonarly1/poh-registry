"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.askTemplateQuestions = exports.askGeneratorQuestions = exports.getTemplates = exports.getSchemaList = exports.getConfiguration = exports.createGeneratorFiles = void 0;
const errors_1 = require("@oclif/errors");
const chalk = require("chalk");
const debug = require("debug");
const node_fetch_1 = require("node-fetch");
const fs = require("fs-extra");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const os = require("os");
const path = require("path");
const shell = require("shelljs");
const constants_1 = require("../shared/constants");
const errors_2 = require("../shared/errors");
const { version } = require('../../package.json');
exports.createGeneratorFiles = async (id, details) => {
    const url = `${constants_1.STEPZEN_DIRECT_GENERATOR_ENGINES_URL}/create`;
    debug('stepzen:generate')(`calling the generator engine ${id} via ${url}`);
    const engineErrorMessageWrap = (msg) => `An error has occurred when creating the schema: ${msg}. Please check your parameters and try again.`;
    try {
        const response = await node_fetch_1.default(url, {
            body: JSON.stringify({
                id,
                details: JSON.stringify(details.answers),
            }),
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': `stepzen-cli/${version}`,
            },
            method: 'POST',
        });
        const responseJson = await response.json();
        if (responseJson.errors) {
            // assuming a response of type { status: Int, errors: String }
            throw new errors_1.CLIError(engineErrorMessageWrap(responseJson.errors));
        }
        else {
            // where errors is an error message if name === null.
            const files = responseJson;
            const tmp = path.join(os.tmpdir(), `stepzen-generated-schema-${Date.now()}`);
            fs.ensureDirSync(tmp);
            for (const file of files) {
                if (file.errors) {
                    throw new errors_1.CLIError(engineErrorMessageWrap(file.errors));
                }
                else {
                    const dir = path.join(tmp, file.name);
                    fs.writeFileSync(dir, file.content);
                }
            }
            return tmp;
        }
    }
    catch (error) {
        debug('stepzen:generate')(error);
        throw error instanceof errors_1.CLIError
            ? error
            : new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
};
exports.getConfiguration = async (id, details = {}) => {
    const url = `${constants_1.STEPZEN_DIRECT_GENERATOR_ENGINES_URL}/configure`;
    debug('stepzen:generate')(`calling the generator engine ${id} via ${url}`);
    try {
        const response = await node_fetch_1.default(url, {
            body: JSON.stringify({
                id,
                details: JSON.stringify(details),
            }),
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': `stepzen-cli/${version}`,
            },
            method: 'POST',
        });
        const { answers, errors, questions, status } = await response.json();
        return {
            answers: JSON.parse(answers),
            errors: JSON.parse(errors),
            questions: JSON.parse(questions),
            status: JSON.parse(status),
        };
    }
    catch (error) {
        debug('stepzen:generate')(error);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
};
exports.getSchemaList = (arg) => {
    const schemas = arg.split(',').map((schema) => schema.trim());
    // Make sure they're unique, otherwise, complain
    for (const schema of schemas) {
        const instances = schemas.filter((s) => s === schema);
        if (instances.length > 1) {
            throw new errors_1.CLIError(`You are trying to import "${schema}" more than once`);
        }
    }
    return schemas.map(schema => {
        // support `postgres` as an alias to `postgresql`
        // https://github.com/steprz/stepzen-cli/issues/431
        if (schema.toLowerCase() === 'postgres') {
            return 'postgresql';
        }
        return schema;
    });
};
exports.getTemplates = async () => {
    const tmp = path.join(os.tmpdir(), `stepzen-api-templates-${Date.now()}`);
    fs.ensureDirSync(tmp);
    const repository = constants_1.STEPZEN_API_TEMPLATES_REPOSITORY;
    const command = `git clone ${repository} ${tmp}`;
    const result = shell.exec(command, { silent: true });
    if (result.code !== 0) {
        throw new errors_1.CLIError(result.stderr.trim());
    }
    return tmp;
};
exports.askGeneratorQuestions = async (id, settings, state) => {
    var _a, _b;
    let status = -1;
    do {
        if (settings.questions.length === 0) {
            // would cause a hot loop, so it's an error
            throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
        }
        const questions = settings.questions.map((question) => (Object.assign(Object.assign({ type: 'password' }, question), { 
            // set the previous iteration's answer as the default value, except for password fields
            default: question.type && question.type !== 'password'
                ? lodash_1.get(state, question.name)
                : undefined })));
        // eslint-disable-next-line no-await-in-loop
        const answers = await inquirer.prompt(questions);
        state = lodash_1.merge(state, answers);
        // eslint-disable-next-line no-await-in-loop
        const result = await exports.getConfiguration(id, state);
        if (!result) {
            // at this point the generator ${id} should have been validated
            throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
        }
        if (result.status === -1 && result.questions.length === 0) {
            console.log();
            console.log(chalk.red(`A problem occurred when running ${id} import${((_a = result.errors) === null || _a === void 0 ? void 0 : _a.error) ? `: "${(_b = result.errors) === null || _b === void 0 ? void 0 : _b.error}"` : '.'}`));
            console.log('Please try again');
        }
        else {
            settings = {
                questions: result.questions,
            };
            // eslint-disable-next-line require-atomic-updates
            state = lodash_1.merge(state, result.answers);
        }
        status = result.status;
    } while (status === -1);
    return state;
};
exports.askTemplateQuestions = async (id, settings, state) => {
    const questions = settings.questions.map((question) => (Object.assign({ type: 'password' }, question)));
    const answers = await inquirer.prompt(questions);
    return Object.assign(Object.assign({}, state), answers);
};
