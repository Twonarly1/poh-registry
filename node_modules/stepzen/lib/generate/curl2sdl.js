"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.curl2sdl = exports.askCurlQuestions = void 0;
const errors_1 = require("@oclif/errors");
const chalk = require("chalk");
const fs = require("fs-extra");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const os = require("os");
const path = require("path");
const string_argv_1 = require("string-argv");
const node_fetch_1 = require("node-fetch");
const debug = require("debug");
const prettier = require("prettier");
const transpiler_1 = require("@stepzen/transpiler");
const curl_parser_1 = require("../shared/curl-parser");
const path_params_parser_1 = require("../shared/path-params-parser");
const constants_1 = require("../shared/constants");
const errors_2 = require("../shared/errors");
exports.askCurlQuestions = async (defaultAnswers = {}) => {
    let questions = [
        {
            name: 'url',
            message: 'Endpoint URL or a full curl command',
        },
        {
            name: 'pathParams',
            message: 'Parameters for endpoint URL path',
        },
        {
            name: 'queryName',
            message: 'Query name to use when generating schema (leave blank to use defaults)',
        },
        {
            name: 'rootType',
            message: 'Query type name to use when generating schema (leave blank to use defaults)',
        },
        {
            name: 'typePrefix',
            message: 'Prefix to add to all generated type name (leave blank to use defaults)',
        },
    ];
    questions = questions.map(question => (Object.assign(Object.assign({}, question), { default: lodash_1.get(defaultAnswers, question.name) })));
    const answers = await inquirer.prompt(questions);
    const curlArgs = curl_parser_1.parseCurlArgv(string_argv_1.default(answers.url));
    if ('error' in curlArgs) {
        console.log();
        console.log(chalk.red('A problem occurred while parsing the curl command:\n', curlArgs.error), '\nPlease enter a URL or a supported curl command.');
        console.log();
        return exports.askCurlQuestions(answers);
    }
    const parsedPathParamsOrError = path_params_parser_1.parsePathParamsPattern(curlArgs.url, answers.pathParams);
    if ('error' in parsedPathParamsOrError) {
        console.log();
        console.log(chalk.red('A problem occurred while parsing path parameters pattern:\n', parsedPathParamsOrError.error));
        console.log();
        console.log(`Please enter a path parameter specification that` +
            ` can be formed by taking the original path and replacing the variable` +
            ` segments with ${chalk.bold('$paramName')} placeholders.`);
        console.log();
        console.log('Example:\n' +
            `\tendpoint URL: https://example.com/users/jane/posts/12\n ` +
            `\tpath parameters: /users/${chalk.bold('$userId')}/posts/${chalk.bold('$postId')}`);
        console.log();
        return exports.askCurlQuestions(answers);
    }
    return {
        curlArgs,
        queryName: answers.queryName,
        rootType: answers.rootType,
        typePrefix: answers.typePrefix,
        pathParams: parsedPathParamsOrError,
    };
};
exports.curl2sdl = async ({ curlArgs, name, source, queryName, rootType, typePrefix, pathParams, }) => {
    let json;
    try {
        const url = `${constants_1.STEPZEN_JSON2SDL_SERVER_URL}/api/graphql`;
        const query = `query (
      $command: String!
      $queryName: String
      $rootType: String
      $typePrefix: String
      $headers: [HeaderInput!]
      $data: String
      $method: HTTPMethod
      $pathParams: [PathParamInput!]
    ) {
      getSDLFromCurl(
        command: $command
        queryName: $queryName
        rootType: $rootType
        typePrefix: $typePrefix
        headers: $headers
        data: $data
        method: $method
        pathParams: $pathParams
      ) {
        sdl
        config
      }
    }`;
        const variables = {
            command: curlArgs.url,
            queryName: queryName || null,
            rootType: rootType || null,
            typePrefix: typePrefix || null,
            headers: curlArgs.headers.length > 0 ? curlArgs.headers : null,
            data: curlArgs.data || null,
            method: curlArgs.method,
            pathParams: pathParams.length > 0 ? pathParams : null,
        };
        debug('stepzen:curl2sdl')(url);
        debug('stepzen:curl2sdl')(query);
        debug('stepzen:curl2sdl')(variables);
        const payload = JSON.stringify({
            query,
            variables,
        });
        debug('stepzen:curl2sdl')(payload);
        const response = await node_fetch_1.default(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                query,
                variables,
            }),
        });
        const text = await response.text();
        debug('stepzen:curl2sdl')(text);
        json = JSON.parse(text);
    }
    catch (error) {
        debug('stepzen:curl2sdl')(error);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (!json.data && !json.errors) {
        debug('stepzen:curl2sdl')('expected the response from the JSON introspection service ' +
            'to contain either `data` or `errors`');
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (json.errors) {
        return { error: json.errors.map((error) => error.message).join('\n') };
    }
    const { getSDLFromCurl } = json.data;
    if (!getSDLFromCurl) {
        debug('stepzen:curl2sdl')('expected the response from the JSON introspection service ' +
            'to contain a `getSDLFromCurl` object');
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    const { config, sdl } = getSDLFromCurl;
    if (!config && !sdl) {
        debug('stepzen:curl2sdl')('expected the response from the JSON introspection service ' +
            'to contain at least one of `getSDLFromCurl.config` or ' +
            '`getSDLFromCurl.sdl` properties');
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    // write out the generated config and schema files
    const tmp = path.join(os.tmpdir(), `stepzen-curl2sdl-${Date.now()}`);
    fs.ensureDirSync(tmp);
    // fs.ensureDirSync(path.join(tmp, subfolder))
    if (config) {
        fs.writeFileSync(path.join(tmp, 'config.yaml'), prettier.format(config, { parser: 'yaml' }));
    }
    if (sdl) {
        fs.writeFileSync(path.join(tmp, 'index.graphql'), prettier.format(sdl, { parser: 'graphql' }));
    }
    const result = await transpiler_1.merge(source, {
        name: name || 'curl',
        source: tmp,
    }, {
        answers: {},
        output: null,
        silent: true,
        mergeTypes: false,
    });
    return { outPath: result };
};
