"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const errors_1 = require("@oclif/errors");
const core_1 = require("@oclif/core");
const fs = require("fs-extra");
const lodash = require("lodash");
const os = require("os");
const path = require("path");
const transpiler_1 = require("@stepzen/transpiler");
const helpers_1 = require("./helpers");
exports.default = async (schemas, name, source) => {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var _e;
    // Store the generators
    const generators = {};
    for (const schema of schemas) {
        generators[schema] = null;
    }
    // Store the answers
    let answers = {};
    // Start downloading
    core_1.CliUx.ux.action.start('Downloading from StepZen...');
    try {
        // Get all generators from...Generators
        for (var _f = tslib_1.__asyncValues(Object.keys(generators)), _g; _g = await _f.next(), !_g.done;) {
            const id = _g.value;
            const configure = await helpers_1.getConfiguration(id, {});
            if (configure) {
                generators[id] = {
                    questions: configure.questions,
                    type: 'generator',
                };
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_a = _f.return)) await _a.call(_f);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Get the API templates repository
    const templates = await helpers_1.getTemplates();
    try {
        for (var _h = tslib_1.__asyncValues(Object.entries(generators)), _j; _j = await _h.next(), !_j.done;) {
            const [id, configuration] = _j.value;
            if (!configuration) {
                if (fs.existsSync(`${templates}/${id}`)) {
                    const file = path.join(templates, id, 'stepzen.config.json');
                    const config = fs.readFileSync(file, 'utf8');
                    const json = JSON.parse(config);
                    generators[id] = {
                        questions: ((_e = json === null || json === void 0 ? void 0 : json.config) === null || _e === void 0 ? void 0 : _e.questions) || [],
                        type: 'template',
                    };
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_b = _h.return)) await _b.call(_h);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // Finished downloading
    core_1.CliUx.ux.action.stop();
    console.log();
    // If you've tried to import non-existent templates, complain and exit
    const notFound = Object.entries(generators)
        .map(([id, settings]) => {
        if (!settings)
            return id;
        return null;
    })
        .filter(i => i);
    if (notFound.length > 0) {
        fs.removeSync(templates);
        throw new errors_1.CLIError(`Cannot find the schema ${notFound[0]}`);
    }
    try {
        // Ask all the questions
        for (var _k = tslib_1.__asyncValues(Object.entries(generators)), _l; _l = await _k.next(), !_l.done;) {
            const [id, generator] = _l.value;
            let result = {};
            if (generator.type === 'generator') {
                result = await helpers_1.askGeneratorQuestions(id, generator, answers);
            }
            else if (generator.type === 'template') {
                result = await helpers_1.askTemplateQuestions(id, generator, answers);
            }
            generators[id].answers = result;
            answers = lodash.merge(answers, result);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_l && !_l.done && (_c = _k.return)) await _c.call(_k);
        }
        finally { if (e_3) throw e_3.error; }
    }
    // We now have all the answers! Generate schemas
    const output = path.join(os.tmpdir(), `stepzen-generated-schema-${Date.now()}`);
    fs.ensureDirSync(output);
    fs.copySync(source, output);
    console.log();
    core_1.CliUx.ux.action.start('Generating schemas...');
    try {
        for (var _m = tslib_1.__asyncValues(Object.entries(generators)), _o; _o = await _m.next(), !_o.done;) {
            const [id, generator] = _o.value;
            if (generator.type === 'generator') {
                const files = await helpers_1.createGeneratorFiles(id, generator);
                const tmp = await transpiler_1.merge(output, {
                    name: id,
                    source: files,
                }, {
                    answers,
                    silent: true,
                    output: null,
                });
                fs.copySync(tmp, output);
                fs.removeSync(files);
                fs.removeSync(tmp);
            }
            if (generator.type === 'template') {
                const tmp = await transpiler_1.merge(output, {
                    name: name || id,
                    source: path.join(templates, id),
                }, {
                    answers,
                    silent: true,
                    output: null,
                });
                fs.copySync(tmp, output);
                fs.removeSync(tmp);
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_o && !_o.done && (_d = _m.return)) await _d.call(_m);
        }
        finally { if (e_4) throw e_4.error; }
    }
    // Housekeeping
    core_1.CliUx.ux.action.stop();
    fs.removeSync(templates);
    return output;
};
