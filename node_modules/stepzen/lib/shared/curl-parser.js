"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCurlArgv = exports.parseCurlHeaderString = void 0;
const constants_1 = require("./constants");
// Based on the existing curl flags at https://curl.se/docs/manpage.html
const curlFlagRegex = /^(-[a-zA-Z0-9.:#])|(--[a-zA-Z0-9.-]+)$/;
// Based on the definition of a `token` at
// https://datatracker.ietf.org/doc/html/rfc2616#page-17
const httpHeaderRegex = /^(?<name>[a-zA-Z0-9!#$%&'*+,-.^_`|~]+)\s*:(?<value>.*)$/;
const httpURLRegex = /^https?:\/\//i;
/**
 * Parse a header string according to https://curl.se/docs/manpage.html#-H
 * and https://datatracker.ietf.org/doc/html/rfc2616#section-4.2
 *
 * @param {*} header a curl header string, e.g. `"api-key: asfdasdfad"`
 * @returns {*} a name/value record or
 *    `null` for the `Header:` notation that means "remove this header" in
 *    the cURL spec or a error object if cannot parse the string.
 */
exports.parseCurlHeaderString = (header) => {
    const trimmed = header.trim();
    // Check if it's a `Header:` case
    if (trimmed.indexOf(':') === trimmed.length - 1) {
        // the user intent was to _remove_ this header
        return null;
    }
    // Check if it's a `Header;` case
    if (trimmed.indexOf(';') === trimmed.length - 1) {
        return {
            name: trimmed.substring(0, trimmed.length - 1).trim(),
            value: '',
        };
    }
    const match = trimmed.match(httpHeaderRegex);
    if (!match || !match.groups || !match.groups.name || !match.groups.value) {
        return {
            error: `Unexpected header syntax in "${header}". ` +
                `Expected "[name]: [value]", "[name];" or "[name]:"`,
        };
    }
    return {
        name: match.groups.name,
        value: match.groups.value.trim(),
    };
};
const isAFlagArg = (arg) => curlFlagRegex.test(arg);
const isAURL = (arg) => httpURLRegex.test(arg);
const parseHeaderFlag = (value, partialCurlArgs) => {
    const headerOrError = exports.parseCurlHeaderString(value);
    if (headerOrError && 'error' in headerOrError) {
        return headerOrError; // error
    }
    const headers = partialCurlArgs.headers || [];
    // A `null` from parseCurlHeaderString() means a header should NOT be
    // sent. This is not supported by zenserv / the introspection service
    // so the CLI simply omits such headers
    if (headerOrError) {
        headers.push(headerOrError); // header
    }
    return {
        result: Object.assign(Object.assign({}, partialCurlArgs), { headers }),
    };
};
const parseDataFlag = (value, partialCurlArgs, match) => {
    if (match !== '--data-raw' && value.charAt(0) === '@') {
        return {
            error: `Reading request data from local files in not currently supported ` +
                `by StepZen CLI (${match} ${value}). If this is a blocker ` +
                `for you, please let us know on Discord (${constants_1.STEPZEN_DISCORD_URL})`,
        };
    }
    const data = (partialCurlArgs.data ? partialCurlArgs.data + '&' : '') + value;
    return {
        result: Object.assign(Object.assign({}, partialCurlArgs), { data }),
    };
};
const parseMethodFlag = (value, partialCurlArgs) => {
    const lowercaseMethod = value.toLowerCase();
    if (lowercaseMethod !== 'post' && lowercaseMethod !== 'get') {
        return {
            error: `The method ${value} is currently not supported.`,
        };
    }
    const method = lowercaseMethod === 'post' ? 'Post' : 'Get';
    return {
        result: Object.assign(Object.assign({}, partialCurlArgs), { method }),
    };
};
const parseURLFlag = (value, partialCurlArgs) => {
    if (partialCurlArgs.url) {
        return {
            error: `Multiple URLs are not currently supported by StepZen CLI (${value}).` +
                ` If this is a blocker for you, please let us know on Discord (${constants_1.STEPZEN_DISCORD_URL})`,
        };
    }
    return {
        result: Object.assign(Object.assign({}, partialCurlArgs), { url: value }),
    };
};
const flags = [
    {
        matches: ['-H', '--header'],
        parse: parseHeaderFlag,
    },
    {
        matches: ['-d', '--data', '--data-ascii', '--data-raw', '--data-binary'],
        parse: parseDataFlag,
    },
    {
        matches: ['-X', '--request'],
        parse: parseMethodFlag,
    },
    {
        matches: ['--url'],
        parse: parseURLFlag,
    },
];
const tryMatchCurlFlag = (matches, argv, i) => {
    for (const match of matches) {
        const isShortFlag = match.length === 2;
        if (isShortFlag && argv[i].startsWith(match) && argv[i].length > 2) {
            return {
                value: argv[i].substring(2),
                match,
            };
        }
        if (argv[i] === match) {
            if (i + 1 >= argv.length) {
                return {
                    error: `The '${argv[i]}' curl flag requires a value`,
                };
            }
            return {
                value: argv[i + 1],
                match,
                skip: 1,
            };
        }
    }
};
/**
 * Parse a curl command line arguments array to a JSON structure consumable by
 * the StepZen introspection service backend.
 *
 * @param {*} argv an array of curl arguments `[
 *      '-H',
 *      'api-key: my-secret-key',
 *      '--header',
 *      'x-custom-options: my-custom-option-2',
 *      'https://test.stepzen.net/version',
 *      '--dir',
 *      '/my-app'
 *    ]`
 * @returns {*} a structured object with the curl arguments
 */
exports.parseCurlArgv = (argv) => {
    var _a;
    if (((_a = argv[0]) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'curl') {
        argv = argv.slice(1);
    }
    let result = {};
    for (let i = 0; i < argv.length; i++) {
        if (isAFlagArg(argv[i])) {
            let isKnownFlag = false;
            for (const flag of flags) {
                const matcherResult = tryMatchCurlFlag(flag.matches, argv, i);
                if (!matcherResult) {
                    // no match => try matching the next flag
                    continue;
                }
                if ('error' in matcherResult) {
                    // flag matched but it requires a value which is missing
                    return matcherResult;
                }
                const parserResult = flag.parse(matcherResult.value, result, matcherResult.match);
                if ('error' in parserResult) {
                    return parserResult;
                }
                result = parserResult.result;
                i += matcherResult.skip || 0;
                isKnownFlag = true;
                break;
            }
            if (!isKnownFlag) {
                return {
                    error: `The '${argv[i]}' curl flag is not currently supported by StepZen CLI.` +
                        ` If this is a blocker for you, please let us know on Discord (${constants_1.STEPZEN_DISCORD_URL})`,
                };
            }
        }
        else {
            // The only curl argument that's not a flag is the URL
            const resultOrError = parseURLFlag(argv[i], result, '');
            if ('error' in resultOrError) {
                return resultOrError;
            }
            result = resultOrError.result;
        }
    }
    if (!result.url) {
        return {
            error: 'curl: a URL is required',
        };
    }
    if (!isAURL(result.url)) {
        return {
            error: `Unsupported URL schema in '${result.url}'.` +
                ` StepZen CLI currently supports 'https' and 'http'.` +
                ` If this is a blocker for you, please let us know on Discord (${constants_1.STEPZEN_DISCORD_URL})`,
        };
    }
    result.headers = result.headers || [];
    result.method = result.method || (result.data ? 'Post' : 'Get');
    // Add the default content-type header if the request has any data
    // in it, and no content-type header is explicitly provided.
    if (result.headers.findIndex(header => header.name.toLowerCase() === 'content-type') === -1 &&
        result.data) {
        result.headers.push({
            name: 'content-type',
            value: 'application/x-www-form-urlencoded',
        });
    }
    return result;
};
