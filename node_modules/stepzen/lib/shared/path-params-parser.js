"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePathParamsPattern = exports.formatPatternDiffWithPath = void 0;
const chalk = require("chalk");
const pathParamRegex = /^\$[_A-Za-z]\w*$/;
// in a literal segment, $ should be escaped as $$
const pathSegmentRegex = /^([^$]|\$\$)+$/;
exports.formatPatternDiffWithPath = (patternSegments, pathSegments) => {
    let hasErrors = false;
    const diff = [];
    for (let i = 0; i < patternSegments.length; i++) {
        const patternSegment = patternSegments[i];
        if (i >= pathSegments.length) {
            diff.push(chalk.red(`< ${patternSegment} >`));
            hasErrors = true;
        }
        else if (pathSegmentRegex.test(patternSegment)) {
            const pathSegment = pathSegments[i];
            if (pathSegment === patternSegment.replace(/\$\$/g, '$')) {
                diff.push(pathSegment);
            }
            else {
                diff.push(chalk.red(`< ${patternSegment} >`));
                hasErrors = true;
            }
        }
        else {
            // If the path segment contains some unescaped (single) $ chars,
            // interpret it as a pattern for now. An error will be reported
            // later (in parsePathParamsPattern) if it doesn't match
            // pathParamRegex (starts with $)
            diff.push(patternSegment);
        }
    }
    for (let i = patternSegments.length; i < pathSegments.length; i++) {
        diff.push(chalk.magenta(`< ${pathSegments[i]} >`));
        hasErrors = true;
    }
    return hasErrors ? diff.join('/') : null;
};
exports.parsePathParamsPattern = (url, pathParamsPattern) => {
    if (!pathParamsPattern) {
        return [];
    }
    if (pathParamsPattern.charAt(0) === '/') {
        pathParamsPattern = pathParamsPattern.slice(1);
    }
    let pathname = new URL(url).pathname;
    if (pathname.charAt(0) === '/') {
        pathname = pathname.slice(1);
    }
    const pathSegments = pathname.split('/');
    const patternSegments = pathParamsPattern.split('/');
    const maybeDiff = exports.formatPatternDiffWithPath(patternSegments, pathSegments);
    if (maybeDiff) {
        return {
            error: `Path parameters do not align with the URL path: /${maybeDiff}`,
        };
    }
    const invalidParameterSegments = patternSegments.filter(segment => !pathSegmentRegex.test(segment) && !pathParamRegex.test(segment));
    if (invalidParameterSegments.length > 0) {
        return {
            error: `The path parameter name '${invalidParameterSegments[0]}' is not` +
                ` allowed. Path parameter names should be valid GraphQL identifiers` +
                ` prefixed with $ (dollar sign). $ in literal path segments must be` +
                ` escaped as $$.`,
        };
    }
    const retval = patternSegments
        .map((segment, index) => ({
        index,
        name: segment,
    }))
        .filter(({ name }) => pathParamRegex.test(name))
        .map(({ index, name }) => ({
        index,
        name: name.slice(1),
    }));
    return retval;
};
