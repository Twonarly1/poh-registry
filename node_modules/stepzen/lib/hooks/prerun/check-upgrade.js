"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUpgrade = exports.shouldCheckVersion = exports.compareMajorVersions = void 0;
const chalk = require("chalk");
const compareVersions = require("compare-versions");
const fs = require("fs-extra");
const debug_1 = require("debug");
const parser_1 = require("@oclif/parser");
const node_fetch_1 = require("node-fetch");
const constants_1 = require("../../shared/constants");
const errors_1 = require("../../shared/errors");
const majorRegexp = /\d+\./;
const timeoutBeta = 1000 * 60 * 60 * 24; // one day
const timeoutStable = 7 * timeoutBeta; // one week
exports.compareMajorVersions = (v1, v2) => {
    const v1Major = v1.match(majorRegexp);
    const v2Major = v2.match(majorRegexp);
    if (!v1Major || !v2Major) {
        return ('Cannot get the major from the version string ' +
            `'${v1Major ? v2 : v1}'. Does it follow semver?`);
    }
    return parseInt(v1Major[0], 10) - parseInt(v2Major[0], 10);
};
exports.shouldCheckVersion = (version) => {
    if (!fs.existsSync(constants_1.STEPZEN_LAST_UPDATE_CHECK_TIMESTAMP)) {
        // always check for a new version if the file does not exist
        return true;
    }
    const { mtime } = fs.statSync(constants_1.STEPZEN_LAST_UPDATE_CHECK_TIMESTAMP);
    const threshold = version.includes('beta') ? timeoutBeta : timeoutStable;
    return new Date().getTime() - mtime.getTime() > threshold;
};
exports.checkUpgrade = async (version) => {
    if (!exports.shouldCheckVersion(version)) {
        return { message: undefined, isBlocking: false };
    }
    let versions;
    try {
        const pkgmeta = await node_fetch_1.default('https://registry.npmjs.org/stepzen').then(r => r.json());
        versions = pkgmeta['dist-tags'];
    }
    catch (error) {
        // cannot connect to npm -> proceed
        debug_1.default('stepzen:check-upgrade')('failed to get the stepzen version info from npm', error);
        return { message: undefined, isBlocking: false };
    }
    let beta = false;
    let latest = versions.latest;
    const result = {
        message: undefined,
        isBlocking: false,
    };
    if (version.includes('beta')) {
        beta = true;
        latest = versions.beta;
    }
    const upgradeable = compareVersions(version, latest);
    if (upgradeable === -1) {
        const diff = `${chalk.grey(version)} => ${latest}`;
        if (beta) {
            result.message = `${chalk.yellow('An upgrade to the beta channel is available:')}
${diff}
${chalk.green('npm install -g stepzen@beta')}
      `;
        }
        else {
            result.message = `${chalk.yellow('An upgrade to StepZen CLI is available:')}
${diff}
${chalk.green('npm install -g stepzen')}
      `;
        }
        const versionCmpLatest = exports.compareMajorVersions(version, latest);
        if (typeof versionCmpLatest === 'string') {
            debug_1.default('stepzen:check-upgrade')(versionCmpLatest);
            result.message = errors_1.UPGRADE_CHECK_ERROR;
            result.isBlocking = true;
        }
        else {
            result.isBlocking = versionCmpLatest < 0;
        }
    }
    try {
        // update the modification time on the file
        fs.writeFileSync(constants_1.STEPZEN_LAST_UPDATE_CHECK_TIMESTAMP, '');
    }
    catch (_a) {
        // ignore
    }
    return result;
};
const hook = async function (options) {
    const { message, isBlocking } = await exports.checkUpgrade(this.config.version);
    // parse the command line to get `flags['non-interactive']`
    const TheCommand = options.Command;
    const { flags } = parser_1.parse(options.argv, Object.assign({ context: this }, TheCommand));
    // In a non-interactive shell only print the upgrade nudge if the upgrade
    // is blocking.
    // For non-blocking upgrades we don't want to print the upgrade nudge when
    // the CLI is executed as a part of a non-interactive shell script. This
    // additional output might by unexpected by the rest of script and could
    // break the pipeline.
    if (message && (isBlocking || !flags['non-interactive'])) {
        this.log('');
        this.log(message.trim());
        this.log('');
    }
    if (isBlocking) {
        this.exit(1);
    }
};
exports.default = hook;
